
classdef PRPSF < handle
    % (C) Copyright 2017                Huang Lab, Weldon School of Biomedical Engineering, 
    %     All rights reserved           Purdue University, West Lafayette, IN, USA
    %
    %                                   Lidke Lab, Physcis and Astronomy,
    %                                   University of New Mexico, Albuquerque,NM, USA                                   
    %                                   
    % Author: Sheng Liu, March 2020
    %
    % PRPSF class for gernerating phase retrieved pupil function and PSF
    %   create object: obj = PRPSF();
    %
    % PRPSF Methods:
    %   prepdata - converting ADU count to photon count and averaging over time dimension
    %   precomputeParam - generate images for k space operation
    %   datapreprocess - operate on BeadData, shift the bead to the center of the image and croped the image around the center into subregions defined by SubroiSize
    %   genMpsf - operate on Mpsf_subroi, generate normalized measured PSF that are used for phase
    %   saveObj - save PRPSF obj in SaveDir with a input saveName 
    %   calcrlb - calculate CRLB based on PSF model from phase retrieval results
    %   phaseretrieve - generate pupil function from measurend PSF using a phase retrieval algorithm
    %   findOTFparam - find SigmaX and SigmaY of a Gaussian filter for OTF rescale 
    %   findXYshift - find x,y shift of selected bead image using a 2D Gaussian fit to the most infocus PSF
    %   fitdefocus - find amount of defocus in z of the measured PSF
    %   genPRfigs - generate figures of phase retrieval result
    %   genZKresult - expand phase retrieved pupil function into zernike polynomials.
    properties
        Zstart = -1; % start position of z, unit in micron
        Zend = 1; % end position of z, unit in micron
        Zstep = 0.4; % step size of z, unit in micron
        Zindstart = 1; % indices of the first z position used for phase retrieval
        Zindend = 6; % indices of the last z position used for phase retrieval
        Zindstep = 1; % increment in index used for phase retrieval
        Zpos; % z position of PSF images
        Beadcenter; % pixel position of selected bead 
        BeadXYshift; % difference between Beadcenter and found bead position, unit is pixel
        BeadData; % bead images after converting ADU count to photon count and averaging over time dimension
        DatadimX; % x dimension of BeadData
        DatadimY; % y dimension of BeadData
        DatadimZ; % z dimension of BeadData
        PSFsize; % out put size of PSF
        SubroiSize; % subregion size of measured PSF used for phase retrieval
        Pixelsize; % pixel size at sample plane, unit is micron
        IterationNum; % iteration number of PR algorithm
        IterationNumK; % iteration number of PR algorithm after which the data preprocess will be changed 
        ZernikeorderN; % maximum order of Zernike coefficient, which is index n defined by Wyant ordering
        OTFratioSize; % subregion size of OTF images, which are used to calculate parameters of Gaussian filter used for OTF rescale
        % PRstruct - out put structure of phase retrieval results
        %   NA
        %   Lambda
        %   RefractiveIndex
        %   Pupil: phase retrieved pupil function
        %           phase: phase image
        %           uwphase: unwrapped phase if phase unwrapping is enabled
        %           mag: magnitude image
        %   Zernike_phase: coefficient of zernike polynomials representing the pupil phase
        %   Zernike_mag: coefficient of zernike polynomials representing the pupil phase
        %   Zernike_complex: coefficient of zernike polynomials representing the complex pupil function, the coefficients are complex numbers
        %   Fittedpupil: Zernike polynomial fitted pupil function
        %                 complex: pupil image with complex values
        %                 phase: phase image
        %                 mag: magnitude image
        %   SigmaX: sigmax of Gaussian filter for OTF rescale, unit is 1/micron in k space, the conversion to real space is 1/(2*pi*SigmaX), unit is micron
        %   SigmaY: sigmay of Gaussian filter for OTF rescale, unit is 1/micron in k space, the conversion to real space is 1/(2*pi*SigmaY), unit is micron
        %   Zernike_phaseinlambda: zernike coefficients describing the phase aberration, unit is lambda
        PRstruct; 
        % PSFstruct - out put structure of various PSFs
        %   PRpsf: PSF directly calculated from phase retrieved pupil function
        %   ZKpsf: PSF generated from Zernike polynomial
        %   Modpsf: PSF generated by applying a Gaussian filter on ZKpsf
        PSFstruct; 
        CCDoffset;% value(s) of CCD offset from gain calibration of the camera
        Gain;% value(s) of gain from gain calibration the camera
        FileDir;% file directory of the measured PSF data
        FileName;% file name of the measured PSF data
        SaveDir;% save directory of PRPSF object        
        Z;% object from Zernike_Polynomials class
        Enableunwrap; % 1: unwrap phase before zernike expansion, 0: phase is not unwrapped
        nMed;% refractive index of the sample medium
        Stagepos; % position of sample stage, micron
        PSFtype; % for bead away from cover glass, use 'IMM'
        mvType; % changing of z is relative to sample or immersion medium, use 'mvstage' or 'mvbead'
        Ztype; % axial position either 'random': random positions, or 'uniform': equally spaced positions
    end
    
    properties (SetAccess = private, GetAccess = private)
        % precomputed images for k space operation
        PhiC; % phi coordinates based on BeadData, it's a image of DatadimX x DatadimY
        ZoC; % r coordinates based on BeadData, it's a image of DatadimX x DatadimY
        Phi; % phi coordinates out put PSF, it's a image of PSFsize x PSFsize
        k_r; % k_r coordinates of out put OTF, it's a image of PSFsize x PSFsize
        k_z;% k_z coordinates of out put OTF, it's a image of PSFsize x PSFsize
        Zo; % r coordinates of out put PSF, it's a image of PSFsize x PSFsize
        NA_constrain; % a circular function defines the cut-off refrequency in Fourier space
        Cos1;% cos(theta1), theta1 is the angle of between the k vector and the optical axis in the sample medium
        Cos3;% cos(theta3), theta3 is the angle of between the k vector and the optical axis in the immersion medium
    end
    
    properties (SetAccess = private, GetAccess = public)
        Mpsf_subroi; % measured PSF after datapreprocess, which is a 3D image stack of SubroiSize x SubroiSize x Datadimz
        Mpsf_extend; % normalized measured PSF used for phase retrieval, which is a 3D image stack of PSFsize x PSFsize x Datadimz        
    end
    methods
        function obj=PRPSF

        end

        function prepdata(obj)
            % prepdata - converting ADU count to photon count and averaging
            % over time dimension.
            tmp = load(fullfile(obj.FileDir,obj.FileName));
            namei = fields(tmp);
            in=double(tmp.(namei{1}));
            in=squeeze(mean(in,3));
            in=(in-obj.CCDoffset)./obj.Gain;
            f=min(in(:));
            %in=in-f+1e-4;
            in(in<=0) = 1e-4;
            obj.BeadData=in;
            [obj.DatadimY,obj.DatadimX,obj.DatadimZ]=size(in);
        end
        function precomputeParam(obj)
            % precomputeParam - generate images for k space operation, and saved in
            % precomputed parameters.
            
            [XC,YC]=meshgrid(-obj.DatadimX/2:obj.DatadimX/2-1,-obj.DatadimY/2:obj.DatadimY/2-1);
            obj.PhiC=atan2(YC,XC);
            obj.ZoC=sqrt(XC.^2+YC.^2);
            
            [X,Y]=meshgrid(-obj.PSFsize/2:obj.PSFsize/2-1,-obj.PSFsize/2:obj.PSFsize/2-1);
            obj.Zo=sqrt(X.^2+Y.^2);
            scale=obj.PSFsize*obj.Pixelsize;
            obj.k_r=obj.Zo./scale;
            obj.Phi=atan2(Y,X);
            Freq_max=obj.PRstruct.NA/obj.PRstruct.Lambda;
            obj.NA_constrain=obj.k_r<Freq_max;
            n = obj.PRstruct.RefractiveIndex;
            obj.k_z = sqrt((n/obj.PRstruct.Lambda)^2-obj.k_r.^2).*obj.NA_constrain;
            sin_theta3 = obj.k_r.*obj.PRstruct.Lambda./n;
            sin_theta1 = n./obj.nMed.*sin_theta3;
            
            obj.Cos1 = sqrt(1-sin_theta1.^2);
            obj.Cos3 = sqrt(1-sin_theta3.^2);

            % create Zernike_Polynomials object
            zk = Zernike_Polynomials();
            %zk.Ordering = 'Wyant';
            zk.Ordering = 'Noll';
            zk.setN(obj.ZernikeorderN);
            zk.initialize();
            [Zrho, Ztheta, Zinit] = ...
               zk.params3_Zernike(obj.Phi, obj.k_r, obj.PRstruct.NA, obj.PRstruct.Lambda);
            zk.matrix_Z(Zrho, Ztheta, Zinit);
            obj.Z = zk;

        end
        
        function datapreprocess(obj)
            % datapreprocess - operate on BeadData, shift the bead to the center of the image and croped the
            % image around the center into subregions defined by SubroiSize. 
            %   The output is Mpsf_subroi. 
            realsize0=floor(obj.SubroiSize/2);
            realsize1=ceil(obj.SubroiSize/2);
            MpsfC=zeros(obj.SubroiSize,obj.SubroiSize,obj.DatadimZ);
            shiftxy=obj.Beadcenter-obj.BeadXYshift;
            for ii=1:obj.DatadimZ
                tmp=fftshift(ifft2(squeeze(obj.BeadData(:,:,ii))));
                shiftphase=-obj.ZoC./obj.DatadimX.*cos(obj.PhiC).*(obj.DatadimX/2-shiftxy(1)-1)-obj.ZoC./obj.DatadimY.*sin(obj.PhiC).*(obj.DatadimY/2-shiftxy(2)-1);
                tmp1=fft2(tmp.*exp(-2*pi.*shiftphase.*1i));
                startx=-realsize0+obj.DatadimX/2+1;endx=realsize1+obj.DatadimX/2;
                starty=-realsize0+obj.DatadimY/2+1;endy=realsize1+obj.DatadimY/2;
                tmp2=abs(tmp1(starty:endy,startx:endx));
                MpsfC(:,:,ii)=tmp2;
            end
            obj.Mpsf_subroi=MpsfC;
        end
        
        function genMpsf(obj)
            % genMpsf- operate on Mpsf_subroi, generate normalized measured PSF that are used for phase
            % retrieval. 
            %   The out put is Mpsf_extend. See paper 
            R1=obj.SubroiSize;
            R=obj.PSFsize;
            N=obj.DatadimZ;
            
            [X1,Y1]=meshgrid(-R1/2:R1/2-1,-R1/2:R1/2-1);
            circleF=sqrt(X1.^2+Y1.^2);
            circleF(circleF<=R1/2)=1;
            circleF(circleF>R1/2)=0;
            if R==R1
                circleF=ones(R,R);
            end
            realsize0=floor(R1/2);
            realsize1=ceil(R1/2);
            starty=-realsize0+R/2+1;endy=realsize1+R/2;
            startx=-realsize0+R/2+1;endx=realsize1+R/2;
            MpsfL=zeros(R,R,N);
            for ii=1:N
                Mpsfo=obj.Mpsf_subroi(:,:,ii);
                Edge=[mean(Mpsfo(1,:)),mean(Mpsfo(R1,:)),mean(Mpsfo(:,1)),mean(Mpsfo(:,R1))];
                bg=max(Edge);
                Fig2=(Mpsfo-bg);
                Fig2=Fig2.*circleF;
                Fig2(Fig2<=0)=0;
                tmp=zeros(R,R);
                tmp(starty:endy,startx:endx)=Fig2;
                Fig2=tmp;
                minimum0=0;
                Fig2(Fig2<=minimum0)=minimum0;
                MpsfL(:,:,ii)=Fig2./sum(sum(Fig2));
            end
            obj.Mpsf_extend=MpsfL;
        end
       
        function saveObj(obj,saveName)
            filename=obj.FileName;
            if isempty(obj.SaveDir)
                error('PRPSF:NoSaveDir','save directry is empty')
            else
                PRFileName=fullfile(obj.SaveDir,[filename(1:end-4) saveName '.mat']);
                save(PRFileName,'obj');
            end
        end
        
        function calcrlb(obj)
            % calcrlb - calculate CRLB based on PSF model from phase retrieval result. 
            %   It uses the CalCRLB class. It gives the CRLB in x,y,z
            %   at z positions defined by [obj.Zstart:0.1:obj.Zend], and at 
            %   given photon and background counts at 1000 and 2 respectively 
            %
            %   see also CalCRLB
            crobj=CalCRLB(obj.PRstruct,'pupil');
            z=[obj.Zstart:0.1:obj.Zend];
            Num=numel(z);
            crobj.Pixelsize=obj.Pixelsize;%micron
            crobj.Xpos=zeros(Num,1);
            crobj.Ypos=zeros(Num,1);
            crobj.Zpos=z';
            crobj.Photon=1000.*ones(Num,1);
            crobj.Bg=2.*ones(Num,1);
            crobj.Boxsize=16;
            crobj.Deltax=0.1;% pixel
            crobj.Deltaz=0.01;% micron
            
            crobj.prepInputparam();
            crobj.calcrlb();
            crobj.genfigs();
            
        end
        
        function calibrategain(obj)
        end
    end
    
end

